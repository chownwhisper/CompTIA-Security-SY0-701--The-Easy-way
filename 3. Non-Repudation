

    Non-Repudiation:
        Uses asymmetric encryption (public/private key pairs) to bind actions to specific individuals.
        Example: If a user signs a contract digitally with their private key, only their corresponding public key can validate the signature. This prevents them from denying that they signed it.

    Proof of Integrity:
        Uses hash functions (e.g., SHA-256) to generate a unique identifier (digest) for a set of data.
        If any part of the data changes, the hash changes completely due to the avalanche effect.
        Useful in verifying files or messages haven’t been altered in transit.

    Proof of Origin:
        Combines digital signatures with public-key infrastructure (PKI) for authentication.
        The sender’s identity is verified by signing the data with a private key and verifying it with the public key.
        Public keys are often distributed and verified through digital certificates issued by trusted Certificate Authorities (CAs).

    Hashing:
        A one-way function that converts input data into a fixed-length string (digest).
        Common algorithms: SHA-256, SHA-1, and MD5 (though MD5 and SHA-1 are considered weak for secure applications).
        Hashing is non-reversible; it’s computationally infeasible to retrieve the original data from the hash, ensuring data security.

    Digital Signatures:
        Uses a private key to encrypt the hash of the message, creating a digital signature.
        Only the corresponding public key can decrypt the signature, thus verifying that it was signed by the private key holder.
        Often part of the RSA or DSA/ECDSA cryptographic algorithms.

    Verifying a Signature:
        The recipient uses the sender’s public key to decrypt the digital signature and retrieve the hash.
        They hash the original message on their side and compare it with the decrypted hash.
        Matching hashes confirm that the message is both authentic and unaltered.

